#!/usr/bin/perl

# we need to disable hash shuffling in order to make as less prints to stdout as possible
BEGIN {
	unless (defined $ENV{PERL_PERTURB_KEYS}) {
		$ENV{PERL_PERTURB_KEYS} = 0;
		exec ( $^X, $0, @ARGV );
		exit 0; # we actually never get here
	}
}

use 5.018;
use strict;
use warnings;
use utf8;
use open qw (:std :utf8);
use Fcntl qw (:seek);
use AnyEvent;
use AnyEvent::I3;
use JSON::XS;
use Encode;
use IO::Socket qw (AF_INET SOCK_STREAM SHUT_WR);
use POSIX qw (setsid);

local $| = 1;

sub add_events ();
sub spawn (@);
sub find_caps_led ();
sub to_hours ($);
sub readconf ();
sub active_win_borders ();

my $CONF = readconf ();
my $i3 = i3 ();
my $done = AnyEvent->condvar;
$i3->connect->recv or die 'Unable to connect to i3';

# event pool
my @EP;

# reload config and re-apply it on SIGHUP
$SIG{HUP} = sub {
	$CONF = readconf ();
	active_win_borders ();
	$#EP = -1;
	add_events ();
};

my @month = ('Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн', 'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек');
my @week_day = ('Вс', 'Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб');

# File handler pool
my $LAHANDLE;
my $MEMINFOHANDLE;
my $CPUTEMPHANDLE;
my $CAPSHANDLE;

# everything for text labels on i3bar
my $wallclock = '';
my $la = '';
my $meminfo = '';
my $cputemp = '';
my $caps_state = '';
my $charge = '';
my $tcp_check = 0;
my $file_check = 0;
my $file_check_mtime = 0;
my $output_string;
my $old_output_string = '';
my $STDIN_FIRST_LINE_DROPPED = 0;

my $CAPS_LED_PATH = find_caps_led ();

# for fetching battery stats via dee-boos :)
my $properties;

# opened windows info storage ref
my $win;

# capture click events and do not override sigstop and sigcont numbers
print << 'EOJSON';
{"version": 1, "click_events": true}
[ [], 
EOJSON

# i3 events should persist over config relads
my $i3_subscription->{window} = sub {
	my $w = shift;

	if (defined $w->{change}) {
		if ($w->{change} eq 'new' ) {
			if (defined $w->{container}->{window_properties}->{instance}) {
				if (defined $win->{instance}->{$w->{container}->{window_properties}->{instance}}) {
					$win->{instance}->{$w->{container}->{window_properties}->{instance}}++;
				} else {
					$win->{instance}->{$w->{container}->{window_properties}->{instance}} = 1;
				}
			}
		} elsif ($w->{change} eq 'close') {
			if (defined $w->{container}->{window_properties}->{instance}) {
				if (defined $win->{instance}->{$w->{container}->{window_properties}->{instance}}) {
					if ($win->{instance}->{$w->{container}->{window_properties}->{instance}} > 1) {
						$win->{instance}->{$w->{container}->{window_properties}->{instance}} --;
					} else {
						delete $win->{instance}->{$w->{container}->{window_properties}->{instance}};
					}
				}
			}
		}

		active_win_borders ();
	}
};

$i3_subscription->{_error} = sub {
	my ($msg) = @_;
	die "Connection to i3 closed: $msg";
};

$i3->subscribe($i3_subscription)->recv->{success} || die 'Unable to subscribe to i3 events';

# now we can add other events
add_events ();

# and start eventloop
$done->recv ();
exit 0;


sub add_events () {
	# Register callbacks/event handlers

	# Actually print messages there
	push @EP, AnyEvent->timer (
		after    => 1,    # sleep 1 second
		interval => 0.3,  # then invoke every 1 second
		cb       => sub { # the callback to invoke
			my $OUTPUT;

			if ($CONF->{app_buttons}) {
				@{$OUTPUT} = @{$CONF->{apps}};
			}

			if ($CONF->{capslock}->{enabled}) {
				if ($caps_state) {
					push @{$OUTPUT}, {
						background => $CONF->{capslock}->{background},
						color => $CONF->{capslock}->{color},
						border => '#edeceb',
						full_text => 'caps',
						markup => 'pango'
					};
				} else {
					push @{$OUTPUT}, {
						color => $CONF->{capslock}->{background},
						background => $CONF->{capslock}->{color},
						border => '#edeceb',
						full_text => 'caps',
						markup => 'pango'
					};
				}
			}

			if ($CONF->{cpu_temp}) {
				push @{$OUTPUT}, { color => '#3e78fd', full_text => $cputemp };
			}

			if ($CONF->{mem}) {
				push @{$OUTPUT}, { color => '#3e78fd', full_text => $meminfo };
			}

			if ($CONF->{la}) {
				push @{$OUTPUT}, { color => '#3e78fd', full_text => "LA: $la" };
			}

			my $vpn_str = 'VPN:';

			if ($CONF->{vpn}->{enabled}) {
				if ($file_check) {
					$vpn_str .= '⍋';
				} else {
					$vpn_str .= '⍒';
				}
			}

			if ($CONF->{vpn}->{tcp_check}->{enabled}) {
				if ($CONF->{vpn}->{enabled}) {
					$vpn_str .= ':';
				}

				if ($tcp_check) {
					$vpn_str .= '✔';
				} else {
					$vpn_str .= '✘';
				}
			}

			if ($CONF->{vpn}->{tcp_check}->{enabled} || $CONF->{vpn}->{enabled}) {
				push @{$OUTPUT}, { color => '#3e78fd', full_text => $vpn_str };
			}

			if ($CONF->{battery}->{enabled}) {
				push @{$OUTPUT}, { color => '#3e78fd', full_text => $charge };
			}

			if ($CONF->{clock}->{enabled}) {
				push @{$OUTPUT}, { color => $CONF->{clock}->{color}, full_text => "<big>$wallclock</big>", markup => 'pango'};
			}

			$output_string = eval { encode_json $OUTPUT };

			if (defined $output_string) {
				if ($output_string ne $old_output_string) {
					print decode ('UTF-8', $output_string) . ",\n";
					$old_output_string = $output_string;
				}
			} else {
				warn $@;
			}

			@{$OUTPUT} = -1;
		}
	);


	# read STDIN
	push @EP, AnyEvent->io (
		fh   => \*STDIN,
		poll => 'r',
		cb   => sub {
			my $msg = <>;

			unless ($STDIN_FIRST_LINE_DROPPED) {
				$msg = <>;
				$STDIN_FIRST_LINE_DROPPED = 1;
			}

			if ($msg) {
				# drop leading ',' if present
				if (substr ($msg, 0, 1) eq ',') {
					$msg = substr $msg, 1;
				}

				my $j = eval { decode_json $msg };

				if (defined $j) {
					foreach (@{$CONF->{apps}}) {
						unless (defined $_->{name}) {
							next;
						}

						unless (defined $j->{name}) {
							next;
						}

						if ($j->{name} eq $_->{name}) {
							spawn ($_->{cmd});
							last;
						}
					}
				}
			}
		}
	);

	# poll caps lock status, on one of my laptop there is no led for this :(
	if ($CONF->{capslock}->{enabled}) {
		push @EP, AnyEvent->timer (
			after    => 0,    # first invoke ASAP
			interval => 0.3,  # then invoke every 0.3 seconds
			cb       => sub { # the callback to invoke
				if (defined $CAPS_LED_PATH) {
					if (defined $CAPSHANDLE) {
						if (tell ($CAPSHANDLE) == -1) {
							unless (open $CAPSHANDLE, '<', $CAPS_LED_PATH) {
								$CAPS_LED_PATH = undef;
								$caps_state = 2;
							}
						}
					} else {
						unless (open $CAPSHANDLE, '<', $CAPS_LED_PATH) {
							$CAPS_LED_PATH = undef;
							$caps_state = 2
						}
					}
				} else {
					$caps_state = 2;
				}

				if ($caps_state ne '2') {
					$caps_state = eval { readline ($CAPSHANDLE) };
					seek $CAPSHANDLE, SEEK_SET, 0;
					chomp $caps_state;
				}
			}
		);
	}

	# poll clock by timer
	if ($CONF->{clock}->{enabled}) {
		push @EP, AnyEvent->timer (
			after    => 0,    # first invoke ASAP
			interval => 1,    # then invoke every 1 second
			cb       => sub { # the callback to invoke
				# Fetch time for clock
				my ($sec, $min, $hour, $mday, $mon, $year, $wday) = (localtime)[0,1,2,3,4,5,6];
				$year = $year + 1900;
				$wallclock = sprintf '     %s, %s %s %s  %02s:%02s  ', $week_day[$wday], $mday, $month[$mon], $year, $hour, $min;
			}
		);
	}

	# poll battery status via upower or /sys
	if ($CONF->{battery}->{enabled}) {
		# borrow data from upower output
		if ($CONF->{battery}->{driver} eq 'upower') {
			push @EP, AnyEvent->timer (
				after    => 0,    # first invoke ASAP
				interval => 10,   # then invoke every 10 seconds
				cb       => sub { # the callback to invoke
					my @up;
					my $str = `upower -i $CONF->{battery}->{upower_device}`;
					$charge = '⚡ ??% • 00:00';

					if ($?) {
						return;
					}

					@up = split /\n/, $str;
					my $percentage;
					my $time_to; # full or empty
					my $state;
					my $hours = 0;
					my $minutes = 0;

					while ($str = pop (@up)) {
						if (substr ($str, 4, 10) eq 'percentage') {
							$percentage = substr $str, 25;
							chomp $percentage;
						} elsif (substr ($str, 4, 5) eq 'state') {
							if (substr ($str, 25, 11) eq 'discharging') {
								$state = '▼';
							} elsif (substr ($str, 25, 8) eq 'charging') {
								$state = '▲';
							} else {
								$state = '•';
							}
						} elsif (substr ($str, 4, 13) eq 'time to empty') {
							$time_to = substr $str, 25;
						} elsif (substr ($str, 4, 12) eq 'time to full') {
							$time_to = substr $str, 25;
						}
					}

					unless (defined $time_to && defined $percentage && defined $state) {
						return;
					}

					chomp $time_to;

					if (substr ($time_to, -7) eq 'minutes') {
						$minutes = substr $time_to, 0, -8;
						$minutes =~ tr/\,/./;
						$minutes = int $minutes;
					} elsif (substr ($time_to, -5) eq 'hours') {
						$hours = substr $time_to, 0, -6;
						$hours =~ tr/\,/./;
						$minutes = int (60 * ($hours - int ($hours)));
					}

					$time_to = sprintf '%02d:%02d', $hours, $minutes;
					$charge = sprintf '⚡ %s %s %s', $percentage, $state, $time_to;
				}
			);
		} else {
			# fallback borrow data from /sys
			push @EP, AnyEvent->timer (
				after    => 0,    # first invoke ASAP
				interval => 10,   # then invoke every 10 seconds
				cb       => sub { # the callback to invoke
					my $current_charge;
					my $charge_max;
					my $state;
					my ($CH, $CCM, $STH);

					unless (open $CH, '<', sprintf "%s/charge_now", $CONF->{battery}->{sys_dir}) {
						$charge = '⚡ ??% •';
						return;
					}

					$current_charge = <$CH>;
					chomp $current_charge;
					close $CH;

					unless (open $CCM, '<', sprintf "%s/charge_full", $CONF->{battery}->{sys_dir}) {
						$charge = '⚡ ??% •';
						return;
					}

					$charge_max = <$CCM>;
					chomp $charge_max;
					close $CCM;

					unless (open $STH, '<', sprintf "%s/status", $CONF->{battery}->{sys_dir}) {
						$charge = '⚡ ??% •';
						return;
					}

					$state = <$STH>;
					chomp $state;
					close $STH;

					if ($state eq 'Charging') {
						$state = '▲';
					} elsif ($state eq 'Discharging') {
						$state = '▼';
					} else {
						$state = '•';
					}

					my $capacity = int (100 * ($current_charge / $charge_max));
					$charge = sprintf '⚡ %s%% %s', $capacity, $state;
				}
			);
		}
	}

	# put all fast accessable stats in one callback
	push @EP, AnyEvent->timer (
		after    => 0,    # first invoke ASAP
		interval => 3,    # then invoke every 3 second
		cb       => sub { # the callback to invoke

			# Fetch Load Average
			if ($CONF->{la}) {
				if (defined $LAHANDLE) {
					if (tell ($LAHANDLE) == -1) {
						open $LAHANDLE, '<', '/proc/loadavg';
					}
				} else {
					open $LAHANDLE, '<', '/proc/loadavg';
				}

				$la = readline $LAHANDLE;
				seek $LAHANDLE, SEEK_SET, 0;
				$la = (split / /ms, $la, 2)[0];
			}

			# populate memory statistics
			if ($CONF->{mem}) {
				if (defined $MEMINFOHANDLE) {
					if (tell ($MEMINFOHANDLE) == -1) {
						open $MEMINFOHANDLE, '<', '/proc/meminfo';
					}
				} else {
					open $MEMINFOHANDLE, '<', '/proc/meminfo';
				}

				my @mem;

				while ( ! eof ($MEMINFOHANDLE) ) {
					push @mem, readline ($MEMINFOHANDLE);
				}

				seek $MEMINFOHANDLE, SEEK_SET, 0;
				@mem = map { substr $_, 0, -4 } @mem;
				my $memtotal = (split /\s+/xms, $mem[0])[1];
				my $memavail  = (split /\s+/xms, $mem[2])[1];
				my $swaptotal = (split /\s+/xms, $mem[14])[1];
				my $swapfree  = (split /\s+/xms, $mem[15])[1];
				my $shmem = (split /\s+/xms, $mem[20])[1];
				my $memused = int (($memtotal - $memavail) / ($memtotal / 100));

				$meminfo = sprintf (
					'M:%d%% SHM:%dM SW:%dM',
					$memused,
					int ($shmem / 1024),
					int (($swaptotal - $swapfree) / 1024)
				);
			}

			# populate cpu temperature info
			if ($CONF->{cpu_temp}) {
				my $hwmon = 1;

				if (defined $CPUTEMPHANDLE) {
					if (tell $CPUTEMPHANDLE == -1) {
						if (open $CPUTEMPHANDLE, '<', '/sys/class/hwmon/hwmon0/temp1_input') {
							$hwmon = 1;
						} else {
							$hwmon = 0;
						}
					}
				} else {
					unless (open $CPUTEMPHANDLE, '<', '/sys/class/hwmon/hwmon0/temp1_input') {
						$hwmon = 0;
					};
				}

				if ($hwmon) {
					$cputemp = readline $CPUTEMPHANDLE;
					seek $CPUTEMPHANDLE, SEEK_SET, 0;
					chomp $cputemp;
					$cputemp = int $cputemp;

					if ($cputemp > 1000) {
						$cputemp = int ($cputemp / 1000);
					}

					$cputemp = sprintf '%s°', $cputemp;
				}
			}
		},
	);

	# Try to tcp connect to server
	if ($CONF->{vpn}->{tcp_check}->{enabled}) {
		push @EP, AnyEvent->timer (
			after    => 0,    # first invoke ASAP
			interval => 5,    # then invoke every 5 seconds
			cb       => sub { # the callback to invoke
				if (
					my $sock = IO::Socket->new (
						Domain   => AF_INET,
						proto    => 'tcp',
						PeerHost => $CONF->{vpn}->{tcp_check}->{host},
						PeerPort => $CONF->{vpn}->{tcp_check}->{port},
						Type     => SOCK_STREAM,
						Timeout  => $CONF->{vpn}->{tcp_check}->{timeout}
					)
				) {
					$sock->shutdown (SHUT_WR);
					$sock->close ();
					$tcp_check = 1;
				} else {
					$tcp_check = 0;
				}
			}
		);
	}

	# check file mtime
	if ($CONF->{vpn}->{enabled}) {
		push @EP, AnyEvent->timer (
			after    => 0,    # first invoke ASAP
			interval => 3,    # then invoke every 3 seconds
			cb       => sub { # the callback to invoke
				my $mtime = (stat $CONF->{vpn}->{statusfile}) [8];

				if (defined $mtime) {
					if (($mtime - $file_check_mtime) < $CONF->{vpn}->{mtime_threshold}) {
						$file_check = 1;
					} else {
						$file_check = 0;
					}

					$file_check_mtime = $mtime;
				} else {
					$mtime = 0;
					$file_check = 0;
				}
			}
		);
	}
}

sub spawn (@) {
	my @args = @_;
	my  $pid = fork ();

	if ($pid) {
		# Parent, work done, return
		return;
	} elsif ($pid == 0) { # Child
		setsid ();
		# it seems that at least vscode creashes if we close stdio handles
		open STDOUT, '>', '/dev/null';
		open STDERR, '>', '/dev/null';
		open STDIN,  '<', '/dev/null';
		$pid = fork ();

		if ($pid) { # Parent
			# in this place parent quits
			exit 0;
		} elsif ($pid == 0) { # Child
			setsid ();
			my $prg = shift @args;
			# weird situation, silently quit here :)
			exit 0 unless (defined $prg);

			if (@args > 0) {
				exec $prg, @args;
			} else {
				exec $prg;
			}
		} else { # Unable to fork()
			print STDERR "[{\"full_text\":\"ERROR: Could not fork new process: $!\",\"color\":\"#ff0000\"}],\n";
		}
	}

	return;
}

sub find_caps_led () {
	my $str;
	opendir my $C, '/sys/class/input';
	my $cnt = 0;

	while (readdir $C) {
		if (-f sprintf ('/sys/class/input/%s/input0::capslock/brightness', $_)) {
			$str = sprintf '/sys/class/input/%s/input0::capslock/brightness', $_;
			last;
		}

		if (-f sprintf ('/sys/class/input/%s/input%s::capslock/brightness', $_, $cnt)) {
			$str = sprintf '/sys/class/input/%s/input%s::capslock/brightness', $_, $cnt;
			last;
		}

		$cnt++;
	}

	closedir $C;
	return $str;
}

sub to_hours ($) {
	my $sec = shift;

	my $hrs = int ($sec / (60 * 60));
	my $min = int (($sec - ($hrs * 60 * 60)) / 60);

	return sprintf '%02d:%02d', $hrs, $min;
}

sub readconf () {
	my $file = "$ENV{HOME}/.i3/i3status-anyevent.json";

	unless (-f $file) {
		$file = "$ENV{HOME}/.i3/config.json";
	}

	my $FH;

	unless (open $FH, '<', $file) {
		die "Unable to open $file: $!\n";
	}

	my $len = (stat $file)[7];
	my $data;
	use bytes;
	my $readlen = read $FH, $data, $len;
	no bytes;
	close $FH;

	unless (defined $readlen) {
		die "Unable to read $file: $!\n";
	}

	if ($readlen != $len) {
		die "Unable to read $file: read $readlen, but stat() reports that file is $len bytes\n";
	}

	my $config = eval { JSON::XS->new->utf8->relaxed->decode ($data) };

	unless ($config) {
		die "Unable to decode $file: $@\n";
	}

	return $config;
}

sub active_win_borders () {
	foreach my $app (@{$CONF->{apps}}) {
		unless (defined $app->{border_inactive}) {
			$app->{border_inactive} = $app->{border};
		}

		unless (defined $app->{border_active}) {
			$app->{border_active} = $app->{border};
		}

		if (defined ($app->{instance}) && defined ($win->{instance}->{$app->{instance}})) {
			$app->{border} = $app->{border_active};
		} else {
			$app->{border} = $app->{border_inactive};
		}
	}
}
